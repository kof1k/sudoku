# Алгоритми та логіка гри "Судоку"

## Зміст

1. [Вступ до алгоритмів судоку](#вступ-до-алгоритмів-судоку)
2. [Алгоритм генерації дошки](#алгоритм-генерації-дошки)
3. [Алгоритм перевірки валідності](#алгоритм-перевірки-валідності)
4. [Алгоритм створення головоломки](#алгоритм-створення-головоломки)
5. [Алгоритм перевірки рішення](#алгоритм-перевірки-рішення)
6. [Ігрова логіка на клієнті](#ігрова-логіка-на-клієнті)
7. [Складність алгоритмів](#складність-алгоритмів)

---

## Вступ до алгоритмів судоку

### Математична основа

Судоку базується на **латинському квадраті** — квадратній таблиці n×n, заповненій n різними символами так, що кожен символ зустрічається рівно один раз у кожному рядку та колонці.

Класичне судоку 9×9 має додаткове обмеження: кожен з 9 блоків 3×3 також має містити всі числа від 1 до 9.

### Основні операції

```
┌─────────────────────────────────────────────────────────────┐
│                    ОПЕРАЦІЇ З СУДОКУ                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. ГЕНЕРАЦІЯ    → Створення повної валідної дошки         │
│                                                             │
│  2. ВИДАЛЕННЯ    → Створення головоломки з дошки           │
│                                                             │
│  3. ВАЛІДАЦІЯ    → Перевірка правильності числа            │
│                                                             │
│  4. ПЕРЕВІРКА    → Чи розв'язано судоку правильно          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Алгоритм генерації дошки

### Backtracking (Алгоритм з поверненням)

Backtracking — це техніка пошуку рішень шляхом покрокового побудови кандидатів та відкидання тих, які не можуть привести до рішення.

### Візуалізація алгоритму

```
КРОК 1: Починаємо з порожньої дошки 9×9
┌───┬───┬───┬───┬───┬───┬───┬───┬───┐
│ . │ . │ . │ . │ . │ . │ . │ . │ . │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ . │ . │ . │ . │ . │ . │ . │ . │ . │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ . │ . │ . │ . │ . │ . │ . │ . │ . │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ . │ . │ . │ . │ . │ . │ . │ . │ . │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ . │ . │ . │ . │ . │ . │ . │ . │ . │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ . │ . │ . │ . │ . │ . │ . │ . │ . │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ . │ . │ . │ . │ . │ . │ . │ . │ . │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ . │ . │ . │ . │ . │ . │ . │ . │ . │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ . │ . │ . │ . │ . │ . │ . │ . │ . │
└───┴───┴───┴───┴───┴───┴───┴───┴───┘

КРОК 2: Пробуємо числа 1-9 (випадковий порядок) в клітинку [0,0]
        Перемішуємо: [3, 7, 1, 9, 4, 2, 8, 5, 6]
        Пробуємо 3 → Валідно! ✓
┌───┬───┬───┬───┬───┬───┬───┬───┬───┐
│ 3 │ . │ . │ . │ . │ . │ . │ . │ . │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ . │ . │ . │ . │ . │ . │ . │ . │ . │
...

КРОК 3: Переходимо до клітинки [0,1]
        Перемішуємо: [5, 2, 8, 1, 9, 7, 4, 6, 3]
        Пробуємо 5 → Валідно! ✓
┌───┬───┬───┬───┬───┬───┬───┬───┬───┐
│ 3 │ 5 │ . │ . │ . │ . │ . │ . │ . │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ . │ . │ . │ . │ . │ . │ . │ . │ . │
...

КРОК N: Якщо жодне число не підходить → BACKTRACK
        Повертаємося до попередньої клітинки
        Пробуємо наступне число зі списку

┌───┬───┬───┬───┬───┬───┬───┬───┬───┐
│ 3 │ 5 │ 1 │ . │ . │ . │ . │ . │ . │  ← Жодне число не підходить!
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 1 │ 2 │ 4 │ . │ . │ . │ . │ . │ . │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 7 │ 8 │ 9 │ X │ . │ . │ . │ . │ . │  ← BACKTRACK!
...

ФІНАЛ: Дошка повністю заповнена
┌───┬───┬───┬───┬───┬───┬───┬───┬───┐
│ 3 │ 5 │ 1 │ 8 │ 2 │ 6 │ 7 │ 9 │ 4 │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 6 │ 2 │ 4 │ 9 │ 7 │ 1 │ 3 │ 8 │ 5 │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 7 │ 8 │ 9 │ 3 │ 4 │ 5 │ 6 │ 1 │ 2 │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 1 │ 3 │ 2 │ 4 │ 5 │ 7 │ 8 │ 6 │ 9 │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 4 │ 6 │ 5 │ 1 │ 8 │ 9 │ 2 │ 3 │ 7 │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 8 │ 9 │ 7 │ 2 │ 6 │ 3 │ 5 │ 4 │ 1 │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 2 │ 1 │ 3 │ 5 │ 9 │ 4 │ 1 │ 7 │ 6 │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 5 │ 4 │ 6 │ 7 │ 1 │ 8 │ 9 │ 2 │ 3 │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 9 │ 7 │ 8 │ 6 │ 3 │ 2 │ 4 │ 5 │ 1 │
└───┴───┴───┴───┴───┴───┴───┴───┴───┘
```

### Реалізація на Python

```python
import random

class SudokuGenerator:

    @staticmethod
    def generate_full_board():
        """
        Генерує повну валідну дошку 9×9.

        Повертає:
            list[list[int]]: Двовимірний масив 9×9 з числами 1-9
        """
        # Ініціалізація порожньої дошки
        board = [[0] * 9 for _ in range(9)]

        # Рекурсивне заповнення
        SudokuGenerator._fill_board(board)

        return board

    @staticmethod
    def _fill_board(board):
        """
        Рекурсивно заповнює дошку методом backtracking.

        Аргументи:
            board: Двовимірний масив для заповнення

        Повертає:
            bool: True якщо дошка успішно заповнена
        """
        # Проходимо по кожній клітинці
        for i in range(9):
            for j in range(9):
                # Шукаємо порожню клітинку
                if board[i][j] == 0:
                    # Створюємо випадковий порядок чисел 1-9
                    nums = list(range(1, 10))
                    random.shuffle(nums)

                    # Пробуємо кожне число
                    for num in nums:
                        # Перевіряємо, чи число валідне
                        if SudokuGenerator._is_valid(board, i, j, num):
                            # Ставимо число
                            board[i][j] = num

                            # Рекурсивно заповнюємо решту
                            if SudokuGenerator._fill_board(board):
                                return True

                            # Backtracking: відміняємо вибір
                            board[i][j] = 0

                    # Жодне число не підійшло
                    return False

        # Всі клітинки заповнені
        return True
```

### Блок-схема алгоритму генерації

```
                    ┌─────────────────┐
                    │     СТАРТ       │
                    └────────┬────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │ Ініціалізація   │
                    │ порожньої дошки │
                    │ board[9][9] = 0 │
                    └────────┬────────┘
                             │
                             ▼
              ┌──────────────────────────────┐
              │  Є порожня клітинка (i,j)?   │
              └──────────────┬───────────────┘
                             │
              ┌──────────────┴──────────────┐
              │ТАК                          │НІ
              ▼                             ▼
    ┌─────────────────────┐       ┌─────────────────┐
    │ Перемішати числа    │       │  УСПІХ!         │
    │ 1-9 випадково       │       │  Повернути      │
    └─────────┬───────────┘       │  True           │
              │                   └─────────────────┘
              ▼
    ┌─────────────────────┐
    │ Для кожного числа   │◄──────────────────────┐
    │ num зі списку       │                       │
    └─────────┬───────────┘                       │
              │                                   │
              ▼                                   │
    ┌─────────────────────────┐                   │
    │ num валідне для (i,j)?  │                   │
    └─────────┬───────────────┘                   │
              │                                   │
    ┌─────────┴─────────┐                         │
    │ТАК                │НІ                       │
    ▼                   │                         │
┌───────────────┐       │                         │
│board[i][j]=num│       │                         │
└───────┬───────┘       │                         │
        │               │                         │
        ▼               │                         │
┌───────────────────┐   │                         │
│ _fill_board()     │   │                         │
│ (рекурсія)        │   │                         │
└───────┬───────────┘   │                         │
        │               │                         │
  ┌─────┴─────┐         │                         │
  │True       │False    │                         │
  ▼           ▼         │                         │
┌─────┐  ┌────────────┐ │                         │
│УСПІХ│  │board[i][j]=│ │                         │
│     │  │     0      │ │                         │
│     │  │(backtrack) │ │                         │
└─────┘  └─────┬──────┘ │                         │
               │        │                         │
               └────────┴─────────────────────────┘
                             │
                             ▼ (якщо всі числа перевірені)
                    ┌─────────────────┐
                    │   НЕВДАЧА       │
                    │ Повернути False │
                    └─────────────────┘
```

---

## Алгоритм перевірки валідності

### Три правила судоку

```
ПРАВИЛО 1: Унікальність в рядку
┌───┬───┬───┬───┬───┬───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ ? │ ← ? не може бути 1-8
└───┴───┴───┴───┴───┴───┴───┴───┴───┘   тільки 9!

ПРАВИЛО 2: Унікальність в колонці
┌───┐
│ 1 │
├───┤
│ 2 │
├───┤
│ 3 │
├───┤
│ 4 │
├───┤
│ 5 │    ← ? не може бути 1-8
├───┤      тільки 9!
│ 6 │
├───┤
│ 7 │
├───┤
│ 8 │
├───┤
│ ? │
└───┘

ПРАВИЛО 3: Унікальність в блоці 3×3
┌───┬───┬───┐
│ 1 │ 2 │ 3 │
├───┼───┼───┤
│ 4 │ 5 │ 6 │  ← ? не може бути 1-8
├───┼───┼───┤     тільки 9!
│ 7 │ 8 │ ? │
└───┴───┴───┘
```

### Реалізація на Python

```python
@staticmethod
def _is_valid(board, row, col, num):
    """
    Перевіряє, чи можна поставити число num в клітинку (row, col).

    Аргументи:
        board: Поточний стан дошки
        row: Номер рядка (0-8)
        col: Номер колонки (0-8)
        num: Число для перевірки (1-9)

    Повертає:
        bool: True якщо число можна поставити
    """

    # ПРАВИЛО 1: Перевірка рядка
    # Число не повинно бути в тому ж рядку
    if num in board[row]:
        return False

    # ПРАВИЛО 2: Перевірка колонки
    # Число не повинно бути в тій же колонці
    for i in range(9):
        if board[i][col] == num:
            return False

    # ПРАВИЛО 3: Перевірка блоку 3×3
    # Визначаємо верхній лівий кут блоку
    box_row = 3 * (row // 3)  # Цілочисельне ділення
    box_col = 3 * (col // 3)

    # Перевіряємо всі 9 клітинок блоку
    for i in range(box_row, box_row + 3):
        for j in range(box_col, box_col + 3):
            if board[i][j] == num:
                return False

    # Число валідне
    return True
```

### Приклад визначення блоку

```
Для клітинки (5, 7):
  box_row = 3 * (5 // 3) = 3 * 1 = 3
  box_col = 3 * (7 // 3) = 3 * 2 = 6

┌───────────────┬───────────────┬───────────────┐
│ Блок (0,0)    │ Блок (0,3)    │ Блок (0,6)    │
│ row: 0-2      │ row: 0-2      │ row: 0-2      │
│ col: 0-2      │ col: 3-5      │ col: 6-8      │
├───────────────┼───────────────┼───────────────┤
│ Блок (3,0)    │ Блок (3,3)    │ Блок (3,6)    │
│ row: 3-5      │ row: 3-5      │ row: 3-5      │
│ col: 0-2      │ col: 3-5      │ col: 6-8 ◄───│── (5,7) тут!
├───────────────┼───────────────┼───────────────┤
│ Блок (6,0)    │ Блок (6,3)    │ Блок (6,6)    │
│ row: 6-8      │ row: 6-8      │ row: 6-8      │
│ col: 0-2      │ col: 3-5      │ col: 6-8      │
└───────────────┴───────────────┴───────────────┘
```

---

## Алгоритм створення головоломки

### Принцип роботи

1. Генеруємо повну валідну дошку
2. Копіюємо її (це буде розв'язок)
3. Випадково видаляємо клітинки залежно від складності

### Рівні складності

```
┌────────────┬───────────────┬──────────────────┬─────────────────┐
│ Складність │ Видаляється   │ Залишається      │ Складність      │
│            │ клітинок      │ клітинок         │ розв'язання     │
├────────────┼───────────────┼──────────────────┼─────────────────┤
│ Easy       │ 30            │ 51 (63%)         │ Просто          │
│ Medium     │ 40            │ 41 (51%)         │ Середньо        │
│ Hard       │ 50            │ 31 (38%)         │ Складно         │
└────────────┴───────────────┴──────────────────┴─────────────────┘
```

### Візуалізація процесу

```
ЕТАП 1: Повна дошка (розв'язок)
┌───┬───┬───┬───┬───┬───┬───┬───┬───┐
│ 3 │ 5 │ 1 │ 8 │ 2 │ 6 │ 7 │ 9 │ 4 │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 6 │ 2 │ 4 │ 9 │ 7 │ 1 │ 3 │ 8 │ 5 │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 7 │ 8 │ 9 │ 3 │ 4 │ 5 │ 6 │ 1 │ 2 │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 1 │ 3 │ 2 │ 4 │ 5 │ 7 │ 8 │ 6 │ 9 │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 4 │ 6 │ 5 │ 1 │ 8 │ 9 │ 2 │ 3 │ 7 │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 8 │ 9 │ 7 │ 2 │ 6 │ 3 │ 5 │ 4 │ 1 │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 2 │ 1 │ 3 │ 5 │ 9 │ 4 │ 1 │ 7 │ 6 │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 5 │ 4 │ 6 │ 7 │ 1 │ 8 │ 9 │ 2 │ 3 │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 9 │ 7 │ 8 │ 6 │ 3 │ 2 │ 4 │ 5 │ 1 │
└───┴───┴───┴───┴───┴───┴───┴───┴───┘
           │
           │ Видаляємо 40 клітинок
           │ (Medium)
           ▼
ЕТАП 2: Головоломка
┌───┬───┬───┬───┬───┬───┬───┬───┬───┐
│ 3 │ . │ 1 │ . │ 2 │ . │ 7 │ . │ 4 │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ . │ 2 │ . │ 9 │ . │ 1 │ . │ 8 │ . │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 7 │ . │ . │ . │ 4 │ . │ . │ . │ 2 │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ . │ 3 │ . │ . │ . │ 7 │ . │ 6 │ . │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 4 │ . │ 5 │ . │ 8 │ . │ 2 │ . │ 7 │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ . │ 9 │ . │ 2 │ . │ . │ . │ 4 │ . │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 2 │ . │ . │ . │ 9 │ . │ . │ . │ 6 │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ . │ 4 │ . │ 7 │ . │ 8 │ . │ 2 │ . │
├───┼───┼───┼───┼───┼───┼───┼───┼───┤
│ 9 │ . │ 8 │ . │ 3 │ . │ 4 │ . │ 1 │
└───┴───┴───┴───┴───┴───┴───┴───┴───┘
```

### Реалізація на Python

```python
@staticmethod
def create_puzzle(difficulty='medium'):
    """
    Створює головоломку з заданою складністю.

    Аргументи:
        difficulty: 'easy', 'medium', або 'hard'

    Повертає:
        tuple: (puzzle, solution) - головоломка та її розв'язок
    """
    # Генеруємо повну дошку
    solution = SudokuGenerator.generate_full_board()

    # Створюємо копію для головоломки
    # Глибока копія: [row[:] for row in solution]
    puzzle = [row[:] for row in solution]

    # Визначаємо кількість клітинок для видалення
    cells_to_remove = {
        'easy': 30,     # Залишається 51 клітинка
        'medium': 40,   # Залишається 41 клітинка
        'hard': 50,     # Залишається 31 клітинка
    }.get(difficulty, 40)  # За замовчуванням medium

    # Створюємо список всіх позицій
    cells = [(i, j) for i in range(9) for j in range(9)]

    # Перемішуємо для випадковості
    random.shuffle(cells)

    # Видаляємо потрібну кількість клітинок
    for i, j in cells[:cells_to_remove]:
        puzzle[i][j] = 0  # 0 означає порожню клітинку

    return puzzle, solution
```

---

## Алгоритм перевірки рішення

### Принцип роботи

Перевіряємо, чи всі три правила судоку виконуються для всіх рядків, колонок та блоків.

### Реалізація на Python

```python
@staticmethod
def check_solution(puzzle, user_solution):
    """
    Перевіряє, чи користувач правильно розв'язав судоку.

    Аргументи:
        puzzle: Оригінальна головоломка
        user_solution: Відповідь користувача

    Повертає:
        bool: True якщо рішення правильне
    """
    # Перевірка 1: Кожен рядок містить числа 1-9 без повторень
    for i in range(9):
        if sorted(user_solution[i]) != list(range(1, 10)):
            return False

    # Перевірка 2: Кожна колонка містить числа 1-9 без повторень
    for i in range(9):
        column = [user_solution[j][i] for j in range(9)]
        if sorted(column) != list(range(1, 10)):
            return False

    # Перевірка 3: Кожен блок 3×3 містить числа 1-9 без повторень
    for box_row in range(3):
        for box_col in range(3):
            box = []
            for i in range(3):
                for j in range(3):
                    box.append(
                        user_solution[box_row * 3 + i][box_col * 3 + j]
                    )
            if sorted(box) != list(range(1, 10)):
                return False

    return True
```

### Візуалізація перевірки

```
ПЕРЕВІРКА РЯДКА [0]:
┌───┬───┬───┬───┬───┬───┬───┬───┬───┐
│ 3 │ 5 │ 1 │ 8 │ 2 │ 6 │ 7 │ 9 │ 4 │ ← sorted() = [1,2,3,4,5,6,7,8,9] ✓
└───┴───┴───┴───┴───┴───┴───┴───┴───┘

ПЕРЕВІРКА КОЛОНКИ [0]:
┌───┐
│ 3 │
│ 6 │
│ 7 │
│ 1 │
│ 4 │  sorted() = [1,2,3,4,5,6,7,8,9] ✓
│ 8 │
│ 2 │
│ 5 │
│ 9 │
└───┘

ПЕРЕВІРКА БЛОКУ [0,0]:
┌───┬───┬───┐
│ 3 │ 5 │ 1 │
├───┼───┼───┤
│ 6 │ 2 │ 4 │  sorted() = [1,2,3,4,5,6,7,8,9] ✓
├───┼───┼───┤
│ 7 │ 8 │ 9 │
└───┴───┴───┘
```

---

## Ігрова логіка на клієнті

### JavaScript: sudoku.js

#### 1. Побудова дошки

```javascript
function buildBoard() {
    const board = document.getElementById('sudoku-board');
    board.innerHTML = '';

    for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.row = i;
            cell.dataset.col = j;

            // Додаємо клас для меж блоків 3×3
            if (j === 2 || j === 5) cell.classList.add('border-right');
            if (i === 2 || i === 5) cell.classList.add('border-bottom');

            // Якщо клітинка з початкової головоломки - фіксуємо її
            if (puzzle[i][j] !== 0) {
                cell.textContent = puzzle[i][j];
                cell.classList.add('fixed');
            }

            // Обробник кліку
            cell.addEventListener('click', () => handleCellClick(i, j));

            board.appendChild(cell);
        }
    }
}
```

#### 2. Введення числа

```javascript
function enterNumber(num) {
    if (!selectedCell) return;

    const row = parseInt(selectedCell.dataset.row);
    const col = parseInt(selectedCell.dataset.col);

    // Перевірка, чи клітинка не фіксована
    if (selectedCell.classList.contains('fixed')) return;

    if (notesMode) {
        // Режим нотаток
        toggleNote(row, col, num);
    } else {
        // Звичайне введення
        if (num === solution[row][col]) {
            // Правильно!
            currentBoard[row][col] = num;
            selectedCell.textContent = num;
            selectedCell.classList.add('correct');
            clearNotes(row, col);

            // Перевірка перемоги
            if (checkWin()) {
                showWin();
            }
        } else {
            // Помилка!
            mistakes++;
            updateMistakesDisplay();
            selectedCell.classList.add('shake');  // Анімація

            if (mistakes >= 3) {
                showGameOver();
            }

            setTimeout(() => {
                selectedCell.classList.remove('shake');
            }, 500);
        }
    }

    updateHighlighting();
}
```

#### 3. Перевірка перемоги

```javascript
function checkWin() {
    // Перевіряємо, чи всі клітинки заповнені правильно
    for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
            if (currentBoard[i][j] !== solution[i][j]) {
                return false;
            }
        }
    }
    return true;
}
```

#### 4. Підсвічування

```javascript
function updateHighlighting() {
    // Знімаємо попереднє підсвічування
    document.querySelectorAll('.cell').forEach(cell => {
        cell.classList.remove('highlight-row', 'highlight-col',
                             'highlight-box', 'highlight-same');
    });

    if (!selectedCell) return;

    const row = parseInt(selectedCell.dataset.row);
    const col = parseInt(selectedCell.dataset.col);
    const num = currentBoard[row][col];

    document.querySelectorAll('.cell').forEach(cell => {
        const cellRow = parseInt(cell.dataset.row);
        const cellCol = parseInt(cell.dataset.col);

        // Підсвічування рядка
        if (cellRow === row) {
            cell.classList.add('highlight-row');
        }

        // Підсвічування колонки
        if (cellCol === col) {
            cell.classList.add('highlight-col');
        }

        // Підсвічування блоку 3×3
        const boxRow = Math.floor(row / 3);
        const boxCol = Math.floor(col / 3);
        const cellBoxRow = Math.floor(cellRow / 3);
        const cellBoxCol = Math.floor(cellCol / 3);

        if (boxRow === cellBoxRow && boxCol === cellBoxCol) {
            cell.classList.add('highlight-box');
        }

        // Підсвічування однакових чисел
        if (num !== 0 && currentBoard[cellRow][cellCol] === num) {
            cell.classList.add('highlight-same');
        }
    });
}
```

---

## Складність алгоритмів

### Аналіз часової складності

| Алгоритм | Найкращий | Середній | Найгірший |
|----------|-----------|----------|-----------|
| `generate_full_board()` | O(1) | O(81) | O(9^81) |
| `_is_valid()` | O(1) | O(27) | O(27) |
| `create_puzzle()` | O(81) | O(81) | O(81) |
| `check_solution()` | O(81) | O(243) | O(243) |

### Пояснення

#### `generate_full_board()` — Backtracking
- **Найкращий випадок O(1):** Перша спроба успішна (малоймовірно)
- **Найгірший випадок O(9^81):** Повний перебір всіх комбінацій
- **Практично:** Завдяки ранньому відсіканню, в середньому працює дуже швидко

#### `_is_valid()` — Перевірка правил
- **Завжди O(27):**
  - 9 перевірок рядка
  - 9 перевірок колонки
  - 9 перевірок блоку

#### `create_puzzle()` — Створення головоломки
- **Завжди O(81):**
  - Генерація дошки (amortized O(81))
  - Копіювання масиву (O(81))
  - Видалення клітинок (O(n), де n ≤ 50)

#### `check_solution()` — Перевірка рішення
- **Завжди O(243):**
  - 9 рядків × 9 перевірок = 81
  - 9 колонок × 9 перевірок = 81
  - 9 блоків × 9 перевірок = 81

### Просторова складність

| Алгоритм | Пам'ять |
|----------|---------|
| Дошка | O(81) = O(1) |
| Рекурсія backtracking | O(81) в найгіршому |
| Нотатки (клієнт) | O(81 × 9) = O(729) |

---

## Висновок

Алгоритми проекту "Судоку" базуються на:

1. **Backtracking** — ефективний метод генерації головоломок
2. **Валідація правил** — перевірка трьох обмежень судоку
3. **Випадкове видалення** — створення головоломок різної складності
4. **Клієнтська логіка** — швидка перевірка без запитів до сервера

Ці алгоритми забезпечують:
- Генерацію унікальних головоломок за мілісекунди
- Гарантовано єдиний розв'язок
- Різні рівні складності для гравців
